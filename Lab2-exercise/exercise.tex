\documentclass[dvipsnames, svgnames, x11names, a4paper,12pt]{article}

% URLs and hyperlinks ---------------------------------------
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=NavyBlue,
    filecolor=magenta,      
    urlcolor=blue,
}
\usepackage{xurl}
%---------------------------------------------------

\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
    language=vhdl,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=left,
    numberstyle=\small\color{gray},
    keywordstyle=\bfseries\color{Green4},
    commentstyle=\color{gray},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    identifierstyle=\color{black}
}

\usepackage{enumitem}

\title{Exercises}
\author{Mahdi Haghverdi}

\begin{document}
    \maketitle    
\section{3.1}
Write an entity declaration for a memory circuit whose input and output ports are
shown below. Use only the \texttt{std\_logic} or \texttt{std\_logic\_vector} data types.

\begin{itemize}
    \item addr: 12-bit address input
    \item  wra: 1-bit write-enable control signal
    \item oen: l-bit output-enable control signal
    \item  bit: bidirectional data bus
\end{itemize}

\subsection{answer}
\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;

entity MemoryCiruit is 
port (
    addr: in std_logic_vector(11 downto 0);
    wra : in std_logic;
    oen : in std_logic;
    bit : inout std_logic_vector(11 downto 0)
);
\end{lstlisting}

\section{3.5}    
Assume that \texttt{a} is a 10-bit signal with the \texttt{std\_logic\_vector(9 downto 0)} data
type. List the 10 bits assigned to the a signal.

\begin{enumerate}[label=(\alph*)]
    \item \texttt{a <= (others=>’1’);}
    \item \texttt{a <= (1|3|5|7|9=>’1’, others=>’O’);}
    \item \texttt{a <= (9|7|2=>’1’, 6=>’0’, O=>’1’ , 1|5|8=>’0’, 3|4=>’0’);}
\end{enumerate}
\subsection{answer}
\begin{enumerate}[label=(\alph*)]
    \item \texttt{"1111111111"}
    \item \texttt{"0101010101"}
    \item \texttt{"1010000101"}
\end{enumerate}
\section{3.6}\label{3.6}
Assume that \texttt{a} and \texttt{y} are 8-bit signals with the \texttt{std\_logic\_vector(7 downto 0)}
data type. If the signals are interpreted as unsigned numbers, the following assignment
statement performs \texttt{a / 8}. Explain.
    
\texttt{y <= “000” \& a (7 downto 3);}   
\subsection{answer}
\section{3.7}    
Assume the same \texttt{a} and \texttt{y} signals in Problem \nameref{3.6}. We want to perform \texttt{a mod 8} and
assign the result to \texttt{y}. Rewrite the previous signal assignment statement using only the \&
operator.
\subsection{answer}
\section{3.8}    
 Assume that the following double-quoted strings are with the \texttt{std\_logic\_vector}
data type. Determine whether the relational operation is syntactically correct. If yes, what
is the result (i.e., \texttt{true} or \texttt{false})?

\begin{enumerate}[label=(\alph*)]
    \item \texttt{"0110" > "1001"}
    \item \texttt{"0110" > "0001001"}
    \item \texttt{2\#1010\# > "1010"}
    \item \texttt{1010 > "1010"}
\end{enumerate}
\subsection{answer}
\section{3.11}    
Determine whether the following signal assignment is syntactically correct. If not,
use the proper conversion function and type casting to correct the problem.
\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
...
signal s1, s2, s3, s4, s5, s6, s7: std_logic_vector(3 downto 0);
signal u1, u2, u3, u4, u5, u6, u7: unsigned(3 downto 0);
signal sg: signed(3 downto 0);
...
u1 <= 2#0001#;
u2 <= u3 and u4;
u5 <= s1 + 1;
u6 <= u3 + u4 + 3;
u7 <= (others=>'1');
s2 <= s3 + s4 - 1;
s5 <= (others=>'1');
s6 <= u3 and u4;
sg <= u3 - 1;
s7 <= not sg;

\end{lstlisting}
\subsection{answer}
\section{3.12} 
For the following VHDL segment, correct the type mismatch with proper conversion
function(s).

\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
...
signal src, dest: std_logic_vector(15 downto 0);
signal amount: std_logic_vector(3 downto 0);
...
dest <= shift_left(src, amount);

\end{lstlisting}
\subsection{answer}
\section{3.13}    
For the following VHDL segment, correct the type mismatch with proper conversion
function(s).
\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
...
signal src, dest: std_logic_vector(15 downto 0);
signal amount: std_logic_vector(3 downto 0);
...
dest <= src sll amount;   
\end{lstlisting}
\subsection{answer}
\section{3.14}    
 For the following VHDL segment, correct the type mismatch with proper conversion
function(s).
\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.numeric_std.all;
...
signal src, dest: std_logic_vector(15 downto 0);
signal amount: std_logic_vector(3 downto 0);
...
dest <= src sll amount;
\end{lstlisting}

\end{document}